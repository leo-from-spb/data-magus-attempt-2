package lb.dmagus.model.concept

import lb.dmagus.model.core.*
import java.util.concurrent.atomic.AtomicReference


/**
 * The invEntry.
 *
 * <p>
 * This class is generated by Gena the Crocodile.
 * Don't modify it manually.
 * </p>
 **/
public open class InvEntry : ConceptElement 
{


    //// LIFE CYCLE STUFF \\\\

    val entity: Entity

    constructor(entity: Entity) : super(entity.model)
    {
        this.entity = entity
    }

    override val parentNode: Node
        get() = entity




    //// NO FAMILIES \\\\

    override val families = emptyList<Family<Node,Element>>()

    override val childNodes: Iterable<Node>
        get() = emptySet()



    
    //// REFERENCES \\\\
    
    final inner class Attributes: References<InvEntry, Attribute>
    {
        constructor() : super()
        override fun newArc(target: Attribute): Arc<InvEntry, Attribute> = InvEntryAttributeArc(this@InvEntry, target)
    }
    val attributes = Attributes()
    



    //// PROPERTIES \\\\


    var unique: Boolean = false
        set (value) {
            if (field == value) return
            modifying()
            field = value
        }

    var primary: Boolean = false
        set (value) {
            if (field == value) return
            modifying()
            field = value
        }




}


/**
 * The invEntry family.
 *
 * <p>
 * This class is generated by Gena the Crocodile.
 * Don't modify it manually.
 * </p>
 **/
public class InvEntryFamily : Family<Entity, InvEntry>
{

    val entity: Entity

    override val owner: Entity
        get() = entity


    private val array: AtomicReference<Array<InvEntry>> = AtomicReference(emptyArray())


    constructor(entity: Entity) : super()
    {
        this.entity = entity
    }


    public fun newInvEntry(): InvEntry
    {
        val invEntry = InvEntry(entity)
        val invEntryInArray = arrayOf(invEntry)

        do {
            val oldArray = array.get();
            val newArray = oldArray + invEntryInArray;
            val ok =
                array.compareAndSet(oldArray, newArray)
        } while (!ok)

        return invEntry
    }

    override fun iterator(): Iterator<InvEntry>
    {
        return array.get().iterator();
    }

    override fun excludeAll(): Array<out InvEntry>
    {
        return array.getAndSet(emptyArray())
    }
}



class InvEntryAttributeArc (invEntry: InvEntry, attribute: Attribute) : Arc<InvEntry,Attribute> (invEntry, attribute)
{
    val invEntry: InvEntry get() = source
    val attribute: Attribute get() = target

    override fun drop()
    {
        source.attributes.unregister(this)
    }
}


