[#ftl]
[#-- @ftlvariable name="" type="lb.dmagus.crocodile.FileContext" --]
[#-- -- --  Element of the Model  -- -- --]
package lb.dmagus.model.${n.pack}

import lb.dmagus.model.core.*
import java.util.concurrent.atomic.AtomicReference

[#-- @formatter:off --]

/**
 * The ${n.name}.
 *
 * <p>
 * This class is generated by Gena the Crocodile.
 * Don't modify it manually.
 * </p>
 **/
public ${n.open} class ${n.klass} : ${n.base} [#list n.interfaces as i], ${i} [/#list]
{

[#if n.top]

    //// TOP SPACE LIFE CYCLE STUFF \\\\

    constructor(model: Model) : super(model)

    override val parentNode: Node
        get() = model

[#else]

    //// LIFE CYCLE STUFF \\\\

    val ${n.parentName}: ${n.parentClass}

    constructor(${n.parentName}: ${n.parentClass}) : super(${n.parentName}.model)
    {
        this.${n.parentName} = ${n.parentName}
    }

    override val parentNode: Node
        get() = ${n.parentName}

[/#if]


[#if n.hasFamilies]

    //// FAMILIES \\\\

    [#list n.families as f]
    public val ${f.names}: ${f.klass}Family = ${f.klass}Family(this)
    [/#list]

    override val families =
        listOf([#list n.families as f]${f.names}[#sep], [/#list])

    override val childNodes: Iterable<Node>
        [#if n.families?size = 1]
        get() = ${n.families?first.names}
        [#else]
        get() = families.flatten()
        [/#if]


[#else]

    //// NO FAMILIES \\\\
    override val families = emptyList<Family<Node,Element>>()

    override val childNodes: Iterable<Node>
        get() = emptySet()

[/#if]


[#if n.hasProperties]

    //// PROPERTIES \\\\

    [#list n.properties as p]

    var ${p.name}: ${p.type} = ${p.default}
        set (value) {
            if (field == value) return
            modifying()
            field = value
        }
    [/#list]

[#else]

    //// NO PROPERTIES \\\\


[/#if]



}


/**
 * The ${n.name} family.
 *
 * <p>
 * This class is generated by Gena the Crocodile.
 * Don't modify it manually.
 * </p>
 **/
public class ${n.klass}Family : Family<${n.parent.klass}, ${n.klass}>
{

    val ${n.parent.name}: ${n.parent.klass}

    override val owner: ${n.parent.klass}
        get() = ${n.parent.name}


    private val array: AtomicReference<Array<${n.klass}>> = AtomicReference(emptyArray())


    constructor(${n.parent.name}: ${n.parent.klass}) : super()
    {
        this.${n.parent.name} = ${n.parent.name}
    }


    public fun new${n.klass}(): ${n.klass}
    {
        val ${n.name} = ${n.klass}(${n.parent.name})
        val ${n.name}InArray = arrayOf(${n.name})

        do {
            val oldArray = array.get();
            val newArray = oldArray + ${n.name}InArray;
            val ok =
                array.compareAndSet(oldArray, newArray)
        } while (!ok)

        return ${n.name}
    }

    override fun iterator(): Iterator<${n.klass}>
    {
        return array.get().iterator();
    }
}

