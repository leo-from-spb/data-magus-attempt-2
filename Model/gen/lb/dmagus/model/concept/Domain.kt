package lb.dmagus.model.concept

import lb.dmagus.model.core.*
import java.util.concurrent.atomic.AtomicReference


/**
 * The domain.
 *
 * <p>
 * This class is generated by Gena the Crocodile.
 * Don't modify it manually.
 * </p>
 **/
public open class Domain : ConceptElement 
{


    //// LIFE CYCLE STUFF \\\\

    val subjectArea: SubjectArea

    constructor(subjectArea: SubjectArea) : super(subjectArea.model)
    {
        this.subjectArea = subjectArea
    }

    override val parentNode: Node
        get() = subjectArea




    //// NO FAMILIES \\\\
    override val families = emptyList<Family<Node,Element>>()

    override val childNodes: Iterable<Node>
        get() = emptySet()






    //// PROPERTIES \\\\


    var abstract: Boolean = false
        set (value) {
            if (field == value) return
            modifying()
            field = value
        }




}


/**
 * The domain family.
 *
 * <p>
 * This class is generated by Gena the Crocodile.
 * Don't modify it manually.
 * </p>
 **/
public class DomainFamily : Family<SubjectArea, Domain>
{

    val subjectArea: SubjectArea

    override val owner: SubjectArea
        get() = subjectArea


    private val array: AtomicReference<Array<Domain>> = AtomicReference(emptyArray())


    constructor(subjectArea: SubjectArea) : super()
    {
        this.subjectArea = subjectArea
    }


    public fun newDomain(): Domain
    {
        val domain = Domain(subjectArea)
        val domainInArray = arrayOf(domain)

        do {
            val oldArray = array.get();
            val newArray = oldArray + domainInArray;
            val ok =
                array.compareAndSet(oldArray, newArray)
        } while (!ok)

        return domain
    }

    override fun iterator(): Iterator<Domain>
    {
        return array.get().iterator();
    }
}



