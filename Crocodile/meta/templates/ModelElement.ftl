[#ftl]
[#-- @ftlvariable name="" type="lb.dmagus.crocodile.FileContext" --]
[#-- -- --  Element of the Model  -- -- --]
package lb.dmagus.model.${n.pack}

import lb.dmagus.model.core.*
import java.util.concurrent.atomic.AtomicReference

[#-- @formatter:off --]

/**
 * The ${n.name}.
 *
 * <p>
 * This class is generated by Gena the Crocodile.
 * Don't modify it manually.
 * </p>
 **/
public ${n.open} class ${n.klass} : ${n.base} [#list n.interfaces as i], ${i} [/#list]
{

[#if n.top]

    //// TOP SPACE LIFE CYCLE STUFF \\\\

    constructor(model: Model) : super(model)

    override val parentNode: Node
        get() = model

[#else]

    //// LIFE CYCLE STUFF \\\\

    val ${n.parentName}: ${n.parentClass}

    constructor(${n.parentName}: ${n.parentClass}) : super(${n.parentName}.model)
    {
        this.${n.parentName} = ${n.parentName}
    }

    override val parentNode: Node
        get() = ${n.parentName}

[/#if]


[#if n.hasFamilies]

    //// FAMILIES \\\\

    [#list n.families as f]
    public val ${f.names}: ${f.klass}Family = ${f.klass}Family(this)
    [/#list]

    override val families =
        listOf([#list n.families as f]${f.names}[#sep], [/#list])

    override val childNodes: Iterable<Node>
        [#if n.families?size = 1]
        get() = ${n.families?first.names}
        [#else]
        get() = families.flatten()
        [/#if]


[#else]

    //// NO FAMILIES \\\\

    override val families = emptyList<Family<Node,Element>>()

    override val childNodes: Iterable<Node>
        get() = emptySet()

[/#if]


[#if n.hasRefs]
    
    //// REFERENCES \\\\
    
    [#list n.refs as r]
    [#if r.multi]
    final inner class ${r.refNamesCap}: References<${n.klass}, ${r.targetClass}>
    {
        constructor() : super()
        override fun newArc(target: ${r.targetClass}): Arc<${n.klass}, ${r.targetClass}> = ${n.klass}${r.refNameCap}Arc(this@${n.klass}, target)
    }
    val ${r.refNames} = ${r.refNamesCap}()
    [#else]
    private var ${r.refName}Arc: ${n.klass}${r.targetClass}Arc? = null
    var ${r.refName}: ${r.targetClass}?
        get() {
            return ${r.refName}Arc?.${r.refName}
        }
        set(value) {
            val oldArc = ${r.refName}Arc
            if (oldArc?.${r.refName} == value) return
            modifying()
            if (oldArc != null) {
                ${r.refName}Arc = null
                oldArc.drop()
            }
            if (value != null) ${r.refName}Arc = ${n.klass}${r.targetClass}Arc(this,value)
        }
    [/#if]
    [/#list]
    
[/#if]


[#if n.hasProperties]

    //// PROPERTIES \\\\

    [#list n.properties as p]

    var ${p.name}: ${p.type} = ${p.default}
        set (value) {
            if (field == value) return
            modifying()
            field = value
        }
    [/#list]

[#else]

    //// NO PROPERTIES \\\\


[/#if]



}


/**
 * The ${n.name} family.
 *
 * <p>
 * This class is generated by Gena the Crocodile.
 * Don't modify it manually.
 * </p>
 **/
public class ${n.klass}Family : Family<${n.parent.klass}, ${n.klass}>
{

    val ${n.parent.name}: ${n.parent.klass}

    override val owner: ${n.parent.klass}
        get() = ${n.parent.name}


    private val array: AtomicReference<Array<${n.klass}>> = AtomicReference(emptyArray())


    constructor(${n.parent.name}: ${n.parent.klass}) : super()
    {
        this.${n.parent.name} = ${n.parent.name}
    }


    public fun new${n.klass}(): ${n.klass}
    {
        val ${n.name} = ${n.klass}(${n.parent.name})
        val ${n.name}InArray = arrayOf(${n.name})

        do {
            val oldArray = array.get();
            val newArray = oldArray + ${n.name}InArray;
            val ok =
                array.compareAndSet(oldArray, newArray)
        } while (!ok)

        return ${n.name}
    }

    override fun iterator(): Iterator<${n.klass}>
    {
        return array.get().iterator();
    }

    override fun excludeAll(): Array<out ${n.klass}>
    {
        return array.getAndSet(emptyArray())
    }
}


[#list n.refs as r]

class ${n.klass}${r.refNameCap}Arc (${n.name}: ${n.klass}, ${r.refName}: ${r.targetClass}) : Arc<${n.klass},${r.targetClass}> (${n.name}, ${r.refName})
{
    val ${n.name}: ${n.klass} get() = source
    val ${r.refName}: ${r.targetClass} get() = target

    override fun drop()
    {
        [#if r.multi]
        source.${r.refNames}.unregister(this)
        [#else]
        source.${r.refName} = null
        super.drop()
        [/#if]
    }
}

[/#list]

